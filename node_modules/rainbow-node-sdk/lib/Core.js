"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("./common/Utils");
const XMPPService_1 = require("./connection/XMPPService");
const RESTService_1 = require("./connection/RESTService");
const HttpService_1 = require("./connection/HttpService");
const Logger_1 = require("./common/Logger");
const ImsService_1 = require("./services/ImsService");
const PresenceService_1 = require("./services/PresenceService");
const ChannelsService_1 = require("./services/ChannelsService");
const ContactsService_1 = require("./services/ContactsService");
const ConversationsService_1 = require("./services/ConversationsService");
const ProfilesService_1 = require("./services/ProfilesService");
const TelephonyService_1 = require("./services/TelephonyService");
const BubblesService_1 = require("./services/BubblesService");
const GroupsService_1 = require("./services/GroupsService");
const AdminService_1 = require("./services/AdminService");
const SettingsService_1 = require("./services/SettingsService");
const FileServerService_1 = require("./services/FileServerService");
const FileStorageService_1 = require("./services/FileStorageService");
const StateManager_1 = require("./common/StateManager");
const CallLogService_1 = require("./services/CallLogService");
const FavoritesService_1 = require("./services/FavoritesService");
const InvitationsService_1 = require("./services/InvitationsService");
const Events_1 = require("./common/Events");
const Options_1 = require("./config/Options");
const ProxyImpl_1 = require("./ProxyImpl");
const ErrorManager_1 = require("./common/ErrorManager");
const semver_1 = require("semver");
const S2SService_1 = require("./services/S2SService");
const packageVersion = require("../package.json");
let _signin;
let _retrieveInformation;
const LOG_ID = "CORE - ";
let Core = class Core {
    constructor(options) {
        let self = this;
        self._signin = (forceStopXMPP, token) => {
            let that = self;
            that.logger.log("debug", LOG_ID + "(signin) _entering_");
            let json = null;
            return new Promise(function (resolve, reject) {
                if (that.options.useXMPP) {
                    return that._xmpp.stop(forceStopXMPP).then(() => {
                        return that._rest.signin(token);
                    }).then((_json) => {
                        json = _json;
                        let headers = {
                            "headers": {
                                "Authorization": "Bearer " + that._rest.token,
                                "x-rainbow-client": "sdk_node",
                                "x-rainbow-client-version": packageVersion.version
                                // "Accept": accept || "application/json",
                            }
                        };
                        return that._xmpp.signin(that._rest.loggedInUser, headers);
                    }).then(function () {
                        that.logger.log("debug", LOG_ID + "(signin) signed in successfully");
                        that.logger.log("debug", LOG_ID + "(signin) _exiting_");
                        resolve(json);
                    }).catch(function (err) {
                        that.logger.log("error", LOG_ID + "(signin) can't signed-in.");
                        that.logger.log("internalerror", LOG_ID + "(signin) can't signed-in", err);
                        that.logger.log("debug", LOG_ID + "(signin) _exiting_");
                        reject(err);
                    });
                }
                if (that.options.useS2S) {
                    return that._rest.signin(token).then((_json) => __awaiter(this, void 0, void 0, function* () {
                        json = _json;
                        let headers = {
                            "headers": {
                                "Authorization": "Bearer " + that._rest.token,
                                "x-rainbow-client": "sdk_node",
                                "x-rainbow-client-version": packageVersion.version
                                // "Accept": accept || "application/json",
                            }
                        };
                        return that._s2s.signin(that._rest.loggedInUser, headers);
                    })).then(function () {
                        that.logger.log("debug", LOG_ID + "(signin) signed in successfully");
                        that.logger.log("debug", LOG_ID + "(signin) _exiting_");
                        resolve(json);
                    }).catch(function (err) {
                        that.logger.log("error", LOG_ID + "(signin) can't signed-in.");
                        that.logger.log("internalerror", LOG_ID + "(signin) can't signed-in", err);
                        that.logger.log("debug", LOG_ID + "(signin) _exiting_");
                        reject(err);
                    });
                }
                else {
                    that._rest.signin(token).then((_json) => {
                        json = _json;
                        let headers = {
                            "headers": {
                                "Authorization": "Bearer " + that._rest.token,
                                "x-rainbow-client": "sdk_node",
                                "x-rainbow-client-version": packageVersion.version
                                // "Accept": accept || "application/json",
                            }
                        };
                        that.logger.log("debug", LOG_ID + "(signin) signed in successfully");
                        that.logger.log("debug", LOG_ID + "(signin) _exiting_");
                        resolve(json);
                    });
                }
            });
        };
        self._retrieveInformation = () => {
            let that = self;
            that.logger.log("debug", LOG_ID + "(_retrieveInformation).");
            //that.logger.log("internal", LOG_ID + "(_retrieveInformation) options : ", that.options);
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (that.options.testOutdatedVersion) {
                    yield that._rest.getRainbowNodeSdkPackagePublishedInfos().then((infos) => {
                        // self.logger.log("internal", LOG_ID +  "(getRainbowNodeSdkPackagePublishedInfos) infos : ", infos);
                        infos.results.forEach((packagePublished) => {
                            if (packagePublished.package.name === packageVersion.name) {
                                //if (packagePublished.package.version !== packageVersion.version) {
                                if (semver_1.lt(packageVersion.version, packagePublished.package.version)) {
                                    self.logger.log("error", LOG_ID + "(getRainbowNodeSdkPackagePublishedInfos)  \n " +
                                        "*******************************************************\n\n", self.logger.colors.red.underline("WARNING : "), self.logger.colors.italic("\n  curent rainbow-node-sdk version : " + packageVersion.version + " is OLDER than the latest available one on npmjs.com : " + packagePublished.package.version + "\n  please update it (npm install rainbow-node-sdk@latest) and use the CHANGELOG to consider the changes."), "\n\n*******************************************************");
                                    let error = {
                                        "label": "curent rainbow-node-sdk version : " + packageVersion.version + " is OLDER than the latest available one on npmjs.com : " + packagePublished.package.version + " please update it (npm install rainbow-node-sdk@latest) and use the CHANGELOG to consider the changes.",
                                        "currentPackage": packageVersion.version,
                                        "latestPublishedPackage": packagePublished.package.version
                                    };
                                    self._eventEmitter.iee.emit("evt_internal_onrainbowversionwarning", error);
                                    //self.events.publish("rainbowversionwarning", error);
                                }
                            }
                        });
                    }).catch((error) => {
                        self.logger.log("error", LOG_ID + "(getRainbowNodeSdkPackagePublishedInfos) error : ", error);
                        // self.logger.log("internalerror", LOG_ID +  "(getRainbowNodeSdkPackagePublishedInfos) error : ", error);
                    });
                }
                if (that.options.useS2S) {
                    return that._contacts.getRosters()
                        .then(() => {
                        return that._profiles.init();
                    }).then(() => {
                        return that._telephony.init();
                    }).then(() => {
                        return that._contacts.init();
                    }).then(() => {
                        return that._fileStorage.init();
                    }).then(() => {
                        return that._fileServer.init();
                    }).then(() => {
                        return that.presence._sendPresenceFromConfiguration();
                    }).then(() => {
                        return that._bubbles.getBubbles();
                    }).then(() => {
                        return that._channels.fetchMyChannels();
                    }).then(() => {
                        return that._groups.getGroups();
                    }).then(() => {
                        //return that.presence.sendInitialPresence();
                        return Promise.resolve();
                    }).then(() => {
                        //return that.im.enableCarbon();
                        return Promise.resolve();
                    }).then(() => {
                        return that._rest.getBots();
                    }).then((bots) => {
                        that._botsjid = bots ? bots.map((bot) => {
                            return bot.jid;
                        }) : [];
                        return Promise.resolve();
                    }).then(() => {
                        return that._conversations.getServerConversations();
                    }).then(() => {
                        return that._calllog.init();
                    }).then(() => {
                        return that._favorites.init();
                    }).then(() => {
                        return that._invitations.init();
                    }).then(() => {
                        return that._s2s.listConnectionsS2S();
                    }).then(() => {
                        resolve();
                    }).catch((err) => {
                        that.logger.log("error", LOG_ID + "(_retrieveInformation) !!! CATCH  Error while initializing services.");
                        that.logger.log("internalerror", LOG_ID + "(_retrieveInformation) !!! CATCH  Error while initializing services : ", err);
                        reject(err);
                    });
                    //return resolve();
                }
                if (that.options.useCLIMode) {
                    return resolve();
                }
                if (that.options.useXMPP) {
                    return that._contacts.getRosters()
                        .then(() => {
                        return that._profiles.init();
                    }).then(() => {
                        return that._telephony.init();
                    }).then(() => {
                        return that._contacts.init();
                    }).then(() => {
                        return that._fileStorage.init();
                    }).then(() => {
                        return that._fileServer.init();
                    }).then(() => {
                        return that.presence._sendPresenceFromConfiguration();
                    }).then(() => {
                        return that._bubbles.getBubbles();
                    }).then(() => {
                        return that._channels.fetchMyChannels();
                    }).then(() => {
                        return that._groups.getGroups();
                    }).then(() => {
                        //return that.presence.sendInitialPresence();
                        return Promise.resolve();
                    }).then(() => {
                        return that.im.enableCarbon();
                    }).then(() => {
                        return that._rest.getBots();
                    }).then((bots) => {
                        that._botsjid = bots ? bots.map((bot) => {
                            return bot.jid;
                        }) : [];
                        return Promise.resolve();
                    }).then(() => {
                        return that._conversations.getServerConversations();
                    }).then(() => {
                        return that._calllog.init();
                    }).then(() => {
                        return that._favorites.init();
                    }).then(() => {
                        return that._invitations.init();
                    }).then(() => {
                        resolve();
                    }).catch((err) => {
                        that.logger.log("error", LOG_ID + "(_retrieveInformation) !!! CATCH  Error while initializing services.");
                        that.logger.log("internalerror", LOG_ID + "(_retrieveInformation) !!! CATCH  Error while initializing services : ", err);
                        reject(err);
                    });
                }
            }));
        };
        self.onTokenRenewed = function onTokenRenewed() {
            self.logger.log("info", LOG_ID + "(tokenSurvey) token successfully renewed");
            self._rest.startTokenSurvey();
        };
        self.onTokenExpired = function onTokenExpired() {
            self.logger.log("info", LOG_ID + "(tokenSurvey) token expired. Signin required");
            /*
                        self._eventEmitter.iee.removeListener("rainbow_tokenrenewed", self.onTokenRenewed.bind(self));
                        self._eventEmitter.iee.removeListener("rainbow_tokenexpired", self.onTokenExpired.bind(self));
            */
            self._eventEmitter.iee.emit("evt_internal_signinrequired");
        };
        self._tokenSurvey = () => {
            let that = self;
            that.logger.log("debug", LOG_ID + "(tokenSurvey) _enter_");
            if (that.options.useCLIMode) {
                that.logger.log("info", LOG_ID + "(tokenSurvey) No token survey in CLI mode");
                return;
            }
            /*
                        that._eventEmitter.iee.removeListener("rainbow_tokenrenewed", that.onTokenRenewed.bind(that));
                        that._eventEmitter.iee.removeListener("rainbow_tokenexpired", that.onTokenExpired.bind(that));
                        that._eventEmitter.iee.on("rainbow_tokenrenewed", that.onTokenRenewed.bind(that));
                        that._eventEmitter.iee.on("rainbow_tokenexpired", that.onTokenExpired.bind(that));
            */
            that._rest.startTokenSurvey();
        };
        // Initialize the logger
        let loggerModule = new Logger_1.Logger(options);
        self.logger = loggerModule.log;
        self.logger.log("debug", LOG_ID + "(constructor) _entering_");
        self.logger.log("debug", LOG_ID + "(constructor) ------- SDK INFORMATION -------");
        self.logger.log("info", LOG_ID + " (constructor) SDK version: " + packageVersion.version);
        self.logger.log("info", LOG_ID + " (constructor) Node version: " + process.version);
        for (let key in process.versions) {
            self.logger.log("info", LOG_ID + " (constructor) " + key + " version: " + process.versions[key]);
        }
        self.logger.log("debug", LOG_ID + "(constructor) ------- SDK INFORMATION -------");
        // Initialize the options
        self.options = new Options_1.Options(options, self.logger);
        self.options.parse();
        // Initialize the Events Emitter
        self._eventEmitter = new Events_1.Events(self.logger, (jid) => {
            return self._botsjid.includes(jid);
        });
        self._eventEmitter.setCore(self);
        self._eventEmitter.iee.on("evt_internal_signinrequired", () => __awaiter(this, void 0, void 0, function* () {
            yield self.signin(true, undefined);
        }));
        self._eventEmitter.iee.on("rainbow_application_token_updated", function (token) {
            self._rest.applicationToken = token;
        });
        self._eventEmitter.iee.on("evt_internal_xmppfatalerror", (err) => __awaiter(this, void 0, void 0, function* () {
            console.log("Error XMPP, Stop le SDK : ", err);
            yield self._stateManager.transitTo(self._stateManager.ERROR, err);
            yield self.stop().then(function (result) {
                //let success = ErrorManager.getErrorManager().OK;
            }).catch(function (err) {
                let error = ErrorManager_1.ErrorManager.getErrorManager().ERROR;
                error.msg = err;
                self.events.publish("stopped", error);
            });
        }));
        self._eventEmitter.iee.on("rainbow_xmppreconnected", function () {
            let that = self;
            //todo, check that REST part is ok too
            self._rest.reconnect().then((data) => {
                self.logger.log("info", LOG_ID + " (rainbow_xmppreconnected) reconnect succeed : so change state to connected");
                self.logger.log("internal", LOG_ID + " (rainbow_xmppreconnected) reconnect succeed : ", data, " so change state to connected");
                return self._stateManager.transitTo(self._stateManager.CONNECTED).then((data2) => {
                    self.logger.log("info", LOG_ID + " (rainbow_xmppreconnected) transition to connected succeed.");
                    self.logger.log("internal", LOG_ID + " (rainbow_xmppreconnected) transition to connected succeed : ", data2);
                    return self._retrieveInformation();
                });
            }).then((data3) => {
                self.logger.log("info", LOG_ID + " (rainbow_xmppreconnected) _retrieveInformation succeed, change state to ready");
                self.logger.log("internal", LOG_ID + " (rainbow_xmppreconnected) _retrieveInformation succeed : ", data3, " change state to ready");
                self._stateManager.transitTo(self._stateManager.READY).then((data4) => {
                    self.logger.log("info", LOG_ID + " (rainbow_xmppreconnected) transition to ready succeed.");
                    self.logger.log("internal", LOG_ID + " (rainbow_xmppreconnected) transition to ready succeed : ", data4);
                });
            }).catch((err) => __awaiter(this, void 0, void 0, function* () {
                // If not already connected, it is an error in xmpp connection, so should failed
                if (!self._stateManager.isCONNECTED()) {
                    self.logger.log("error", LOG_ID + " (rainbow_xmppreconnected) REST connection ", self._stateManager.FAILED);
                    self.logger.log("internalerror", LOG_ID + " (rainbow_xmppreconnected) REST connection ", self._stateManager.FAILED, ", ErrorManager : ", err);
                    yield self._stateManager.transitTo(self._stateManager.FAILED);
                }
                else {
                    self.logger.log("warn", LOG_ID + " (rainbow_xmppreconnected) REST reconnection Error, set state : ", self._stateManager.DISCONNECTED);
                    self.logger.log("internalerror", LOG_ID + " (rainbow_xmppreconnected) REST reconnection ErrorManager : ", err, ", set state : ", self._stateManager.DISCONNECTED);
                    // ErrorManager in REST micro service, so let say it is disconnected
                    yield self._stateManager.transitTo(self._stateManager.DISCONNECTED);
                    // relaunch the REST connection.
                    self._eventEmitter.iee.emit("rainbow_xmppreconnected");
                }
            }));
        });
        self._eventEmitter.iee.on("rainbow_xmppreconnectingattempt", function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield self._stateManager.transitTo(self._stateManager.RECONNECTING);
            });
        });
        self._eventEmitter.iee.on("rainbow_xmppdisconnect", function (xmppDisconnectInfos) {
            return __awaiter(this, void 0, void 0, function* () {
                if (xmppDisconnectInfos && xmppDisconnectInfos.reconnect) {
                    self.logger.log("info", LOG_ID + " (rainbow_xmppdisconnect) set to state : ", self._stateManager.DISCONNECTED);
                    yield self._stateManager.transitTo(self._stateManager.DISCONNECTED);
                }
                else {
                    self.logger.log("info", LOG_ID + " (rainbow_xmppdisconnect) set to state : ", self._stateManager.STOPPED);
                    yield self._stateManager.transitTo(self._stateManager.STOPPED);
                }
            });
        });
        self._eventEmitter.iee.on("rainbow_tokenrenewed", self.onTokenRenewed.bind(self));
        self._eventEmitter.iee.on("rainbow_tokenexpired", self.onTokenExpired.bind(self));
        if (self.options.useXMPP) {
            self.logger.log("info", LOG_ID + "(constructor) used in XMPP mode");
        }
        else {
            if (self.options.useCLIMode) {
                self.logger.log("info", LOG_ID + "(constructor) used in CLI mode");
            }
            else {
                self.logger.log("info", LOG_ID + "(constructor) used in HOOK mode");
            }
        }
        // Instantiate basic service
        self._proxy = new ProxyImpl_1.ProxyImpl(self.options.proxyOptions, self.logger);
        self._http = new HttpService_1.HTTPService(self.options.httpOptions, self.logger, self._proxy, self._eventEmitter.iee);
        self._rest = new RESTService_1.RESTService(self.options.credentials, self.options.applicationOptions, self.options._isOfficialRainbow(), self._eventEmitter.iee, self.logger);
        self._xmpp = new XMPPService_1.XMPPService(self.options.xmppOptions, self.options.imOptions, self.options.applicationOptions, self._eventEmitter.iee, self.logger, self._proxy);
        self._s2s = new S2SService_1.S2SService(self.options.s2sOptions, self.options.imOptions, self.options.applicationOptions, self._eventEmitter.iee, self.logger, self._proxy, self.options.servicesToStart.s2s);
        // Instantiate State Manager
        self._stateManager = new StateManager_1.StateManager(self._eventEmitter, self.logger);
        // Instantiate others Services
        self._im = new ImsService_1.IMService(self._eventEmitter.iee, self.logger, self.options.imOptions, self.options.servicesToStart.im);
        self._presence = new PresenceService_1.PresenceService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.presence);
        self._channels = new ChannelsService_1.ChannelsService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.channels);
        self._contacts = new ContactsService_1.ContactsService(self._eventEmitter.iee, self.options.httpOptions, self.logger, self.options.servicesToStart.contacts);
        self._conversations = new ConversationsService_1.ConversationsService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.conversations, self.options.imOptions.conversationsRetrievedFormat, self.options.imOptions.nbMaxConversations);
        self._profiles = new ProfilesService_1.ProfilesService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.profiles);
        self._telephony = new TelephonyService_1.TelephonyService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.telephony);
        self._bubbles = new BubblesService_1.BubblesService(self._eventEmitter.iee, self.options.httpOptions, self.logger, self.options.servicesToStart.bubbles);
        self._groups = new GroupsService_1.GroupsService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.groups);
        self._admin = new AdminService_1.AdminService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.admin);
        self._settings = new SettingsService_1.SettingsService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.settings);
        self._fileServer = new FileServerService_1.FileServerService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.fileServer);
        self._fileStorage = new FileStorageService_1.FileStorageService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.fileStorage);
        self._calllog = new CallLogService_1.CallLogService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.calllog);
        self._favorites = new FavoritesService_1.FavoritesService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.favorites);
        self._invitations = new InvitationsService_1.InvitationsService(self._eventEmitter.iee, self.logger, self.options.servicesToStart.invitation);
        self._botsjid = [];
        self.logger.log("debug", LOG_ID + "(constructor) _exiting_");
    }
    start(token) {
        let that = this;
        this.logger.log("debug", LOG_ID + "(start) _entering_");
        this.logger.log("info", LOG_ID + "(start) STARTING the SDK : ", packageVersion.version);
        return new Promise(function (resolve, reject) {
            try {
                if (!that.options.hasCredentials && !token) {
                    that.logger.log("error", LOG_ID + "(start) No credentials. Stop loading...");
                    that.logger.log("debug", LOG_ID + "(start) _exiting_");
                    reject("Credentials are missing. Check your configuration!");
                }
                else {
                    that.logger.log("debug", LOG_ID + "(start) start all modules");
                    that.logger.log("internal", LOG_ID + "(start) start all modules for user : ", that.options.credentials.login);
                    that.logger.log("internal", LOG_ID + "(start) servicesToStart : ", that.options.servicesToStart);
                    return that._stateManager.start().then(() => {
                        return that._http.start();
                    }).then(() => {
                        return that._rest.start(that._http);
                    }).then(() => {
                        return that._xmpp.start(that.options.useXMPP);
                    }).then(() => {
                        return that._s2s.start(that.options, that);
                    }).then(() => {
                        return that._settings.start(that.options, that);
                    }).then(() => {
                        return that._presence.start(that.options, that);
                    }).then(() => {
                        return that._contacts.start(that.options, that);
                    }).then(() => {
                        return that._bubbles.start(that.options, that);
                    }).then(() => {
                        return that._conversations.start(that.options, that);
                    }).then(() => {
                        return that._profiles.start(that.options, that, []);
                    }).then(() => {
                        return that._telephony.start(that.options, that);
                    }).then(() => {
                        return that._im.start(that.options, that);
                    }).then(() => {
                        return that._channels.start(that.options, that);
                    }).then(() => {
                        return that._groups.start(that.options, that);
                    }).then(() => {
                        return that._admin.start(that.options, that);
                    }).then(() => {
                        return that._fileServer.start(that.options, that);
                    }).then(() => {
                        return that._fileStorage.start(that.options, that);
                    }).then(() => {
                        return that._calllog.start(that.options, that);
                    }).then(() => {
                        return that._favorites.start(that.options, that);
                    }).then(() => {
                        return that._invitations.start(that.options, that, []);
                    }).then(() => {
                        that.logger.log("debug", LOG_ID + "(start) all modules started successfully");
                        that._stateManager.transitTo(that._stateManager.STARTED).then(() => {
                            that.logger.log("debug", LOG_ID + "(start) _exiting_");
                            resolve();
                        }).catch((err) => {
                            reject(err);
                        });
                    }).catch((err) => {
                        that.logger.log("error", LOG_ID + "(start) !!! CATCH Error during bulding services instances.");
                        that.logger.log("internalerror", LOG_ID + "(start) !!! CATCH Error during bulding services instances : ", err);
                        that.logger.log("debug", LOG_ID + "(start) _exiting_");
                        reject(err);
                    });
                }
            }
            catch (err) {
                that.logger.log("error", LOG_ID + "(start)");
                that.logger.log("internalerror", LOG_ID + "(start)", err.message);
                that.logger.log("debug", LOG_ID + "(start) _exiting_");
                reject(err);
            }
        });
    }
    signin(forceStopXMPP, token) {
        let that = this;
        return new Promise(function (resolve, reject) {
            let json = null;
            return that._signin(forceStopXMPP, token).then(function (_json) {
                json = _json;
                that._tokenSurvey();
                return that._stateManager.transitTo(that._stateManager.CONNECTED).then(() => {
                    return that._retrieveInformation();
                });
            }).then(() => {
                that._stateManager.transitTo(that._stateManager.READY).then(() => {
                    resolve(json);
                }).catch((err) => { reject(err); });
            }).catch((err) => {
                reject(err);
            });
        });
    }
    stop() {
        let that = this;
        this.logger.log("debug", LOG_ID + "(stop) _entering_");
        return new Promise(function (resolve, reject) {
            if (that._stateManager.isSTOPPED()) {
                return resolve("core already stopped !");
            }
            that.logger.log("debug", LOG_ID + "(stop) stop all modules");
            that._s2s.stop().then(() => {
                return that._rest.stop();
            }).then(() => {
                return that._http.stop();
            }).then(() => {
                return that._xmpp.stop(that.options.useXMPP);
            }).then(() => {
                return that._im.stop();
            }).then(() => {
                return that._settings.stop();
            }).then(() => {
                return that._presence.stop();
            }).then(() => {
                return that._conversations.stop();
            }).then(() => {
                return that._telephony.stop();
            }).then(() => {
                return that._contacts.stop();
            }).then(() => {
                return that._bubbles.stop();
            }).then(() => {
                return that._channels.stop();
            }).then(() => {
                return that._groups.stop();
            }).then(() => {
                return that._admin.stop();
            }).then(() => {
                return that._fileServer.stop();
            }).then(() => {
                return that._fileStorage.stop();
            }).then(() => {
                return that._stateManager.stop();
            }).then(() => {
                return that._calllog.stop();
            }).then(() => {
                return that._favorites.stop();
            }).then(() => {
                return that._invitations.stop();
            }).then(() => {
                that.logger.log("debug", LOG_ID + "(stop) _exiting_");
                resolve("core stopped");
            }).catch((err) => {
                that.logger.log("error", LOG_ID + "(stop) CATCH Error !!! ");
                that.logger.log("internalerror", LOG_ID + "(stop) CATCH Error !!! : ", err);
                that.logger.log("debug", LOG_ID + "(stop) _exiting_");
                reject(err);
            });
        });
    }
    get settings() {
        return this._settings;
    }
    get presence() {
        return this._presence;
    }
    get profiles() {
        return this._profiles;
    }
    get im() {
        return this._im;
    }
    get invitations() {
        return this._invitations;
    }
    get contacts() {
        return this._contacts;
    }
    get conversations() {
        return this._conversations;
    }
    get channels() {
        return this._channels;
    }
    get bubbles() {
        return this._bubbles;
    }
    get groups() {
        return this._groups;
    }
    get admin() {
        return this._admin;
    }
    get fileServer() {
        return this._fileServer;
    }
    get fileStorage() {
        return this._fileStorage;
    }
    get events() {
        return this._eventEmitter;
    }
    get rest() {
        return this._rest;
    }
    get state() {
        return this._stateManager.state;
    }
    get version() {
        return packageVersion.version;
    }
    get telephony() {
        return this._telephony;
    }
    get calllog() {
        return this._calllog;
    }
};
Core = __decorate([
    Utils_1.logEntryExit(LOG_ID)
], Core);
exports.Core = Core;
//module.exports = Core;
module.exports.Core = Core;
//# sourceMappingURL=Core.js.map
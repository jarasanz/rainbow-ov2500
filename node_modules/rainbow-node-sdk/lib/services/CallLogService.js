"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("../common/Utils");
const PubSub = require("pubsub-js");
const calllogEventHandler_1 = require("../connection/XMPPServiceHandler/calllogEventHandler");
const Utils_2 = require("../common/Utils");
const LOG_ID = "CALLLOG/SVCE - ";
function CallLogsBean() {
    return {
        "callLogs": [],
        "orderByNameCallLogs": [],
        "orderByDateCallLogs": [],
        "orderByNameCallLogsBruts": [],
        "orderByDateCallLogsBruts": [],
        "simplifiedCallLogs": [],
        "numberMissedCalls": 0,
        "lastTimestamp": 0
    };
}
let CallLogService = 
/**
* @module
* @name CallsLog
 * @version 1.69.0-debug-24th-03-2020--03-54-58.0 
* @public
* @description
*      This service allow to get the call log and manage it. <br><br>
*      The main methods and events proposed in that service allow to: <br>
*      - Get all calls log <br/>
*      - Delete one or all calls log <br/>
*      - Mark calls as read / unread <br/>
*/
class CallLogService {
    // $q, $log, $rootScope, $interval, contactService, xmppService, CallLog, orderByFilter, profileService, $injector, telephonyService, webrtcGatewayService
    constructor(_eventEmitter, logger, _startConfig) {
        this.ready = false;
        /*********************************************************/
        /**                 LIFECYCLE STUFF                     **/
        /*********************************************************/
        this._startConfig = _startConfig;
        //let that = this;
        this._eventEmitter = _eventEmitter;
        this.logger = logger;
        this._xmpp = null;
        this._rest = null;
        this._s2s = null;
        this._options = {};
        this._useXMPP = false;
        this._useS2S = false;
        this.started = false;
        this._initialized = false;
        this.ready = false;
        /*this.callLogs = [];
        this.orderByNameCallLogs = [];
        this.orderByDateCallLogs = [];
        this.orderByDateCallLogsBruts = [];
        this.simplifiedCallLogs = []; // */
        this.calllogs = CallLogsBean();
        this.callLogHandlerRef = null;
        this.callLogMessageAckRef = null;
        this.callLogNotificationRef = null;
        //        this.numberMissedCalls = 0;
        //        this.lastTimestamp = null;
        this.callLogsHistory = [];
        this.telephonyCallLog = {};
        this.telephonyCallLogHistory = {};
        this.deferedObject = null;
        this.callLogComplete = false;
        this.callLogIndex = -1;
        this._eventEmitter.on("evt_internal_calllogupdated", this.onCallLogUpdated.bind(this));
        this._eventEmitter.on("evt_internal_calllogackupdated", this.onCallLogAckReceived.bind(this));
    }
    get startConfig() {
        return this._startConfig;
    }
    start(_options, _core) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that._xmpp = _core._xmpp;
            that._rest = _core._rest;
            that._contacts = _core.contacts;
            that._profiles = _core.profiles;
            that._telephony = _core.telephony;
            that._options = _options;
            that._s2s = _core._s2s;
            that._useXMPP = that._options.useXMPP;
            that._useS2S = that._options.useS2S;
            this.calllogHandlerToken = [];
            that.logger.log("info", LOG_ID + " ");
            that.logger.log("info", LOG_ID + "[start] === STARTING ===");
            this.attachHandlers();
            this.ready = true;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that.logger.log("info", LOG_ID + "[stop] Stopping");
            //remove all saved call logs
            this.started = false;
            this._initialized = false;
            //this.callLogs = [];
            //this.callLogsPromises = [];
            this.callLogHandlerRef = null;
            this.callLogMessageAckRef = null;
            this.calllogs = CallLogsBean();
            this.telephonyCallLog = {};
            this.telephonyCallLogHistory = {};
            this.callLogComplete = false;
            this.callLogIndex = -1;
            this.callLogsHistory = [];
            that._xmpp = null;
            that._rest = null;
            that._contacts = null;
            that._profiles = null;
            delete that._calllogEventHandler;
            that._calllogEventHandler = null;
            if (that.calllogHandlerToken) {
                that.calllogHandlerToken.forEach((token) => PubSub.unsubscribe(token));
            }
            that.calllogHandlerToken = [];
            this.ready = false;
            that.logger.log("info", LOG_ID + "[stop] Stopped");
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            //that._eventEmitter.on("rainbow_oncalllogupdated", that.onIqCallLogNotificationReceived.bind(that));
            yield Utils_1.setTimeoutPromised(3000).then(() => {
                let startDate = new Date();
                that.getCallLogHistoryPage()
                    .then(() => {
                    // @ts-ignore
                    let duration = new Date() - startDate;
                    let startDuration = Math.round(duration);
                    that.logger.log("info", LOG_ID + " callLogService start duration : ", startDuration);
                    that.logger.log("info", LOG_ID + "[start] === STARTED (" + startDuration + " ms) ===");
                    that.started = true;
                })
                    .catch((error) => {
                    that.logger.log("error", LOG_ID + "[start] === STARTING FAILURE ===");
                    that.logger.log("internalerror", LOG_ID + "[start] === STARTING FAILURE === : ", error);
                });
            });
        });
    }
    attachHandlers() {
        let that = this;
        that.logger.log("info", LOG_ID + "(attachHandlers)");
        that._calllogEventHandler = new calllogEventHandler_1.CallLogEventHandler(that._xmpp, that, that._contacts, that._profiles, that._telephony);
        that.calllogHandlerToken = [
            PubSub.subscribe(that._xmpp.hash + "." + that._calllogEventHandler.IQ_CALLLOG, that._calllogEventHandler.onIqCallLogReceived),
            PubSub.subscribe(that._xmpp.hash + "." + that._calllogEventHandler.CALLLOG_ACK, that._calllogEventHandler.onCallLogAckReceived),
            PubSub.subscribe(that._xmpp.hash + "." + that._calllogEventHandler.IQ_CALLOG_NOTIFICATION, that._calllogEventHandler.onIqCallLogNotificationReceived)
        ];
        /*
        //if reconnection, update the call-logs
        if (that.started && that.lastTimestamp) {
            $interval(function () {
                that.getCallLogHistoryPage(that.lastTimestamp);
            }, 1000, 1, true);
        }
        // */
    }
    /*********************************************************/
    /**       MAM REQUESTS                                  **/
    /*********************************************************/
    getCallLogHistoryPage(useAfter) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that.logger.log("info", LOG_ID + "(getCallLogHistoryPage)");
            if (that._useXMPP) {
                return yield that._xmpp.sendGetCallLogHistoryPage(useAfter);
            }
            if (that._useS2S) {
                return Promise.resolve();
            }
        });
    }
    /*********************************************************/
    /**                     API                             **/
    /*********************************************************/
    /**
     * @public
     * @method getAll
     * @instance
     * @description
     *    Get all calls log history for the connected user
     * @return {CallLog[]} An array of call log entry
     */
    getAll() {
        let that = this;
        that.calllogs = this._calllogEventHandler.orderCallLogsFunction();
        let callLogs = that.getSimplifiedCallLogs();
        // as duration is "h[H] mm[m] ss[s]" in rb, switch it back to ms ...
        for (let i = 0; i < callLogs.length; i++) {
            let durationMs = 0;
            let hmmss = callLogs[i].duration;
            if (hmmss && (typeof hmmss === "string") && hmmss.match(/^(?:(?:([01]?\d|2[0-3])h )?([0-5]?\d)m )?([0-5]?\ds)$/)) {
                // Remove h, m and s
                hmmss = hmmss.replace(/[hms]/g, "");
                // split it at the "space", also reverse it to get seconds then minutes then hours
                let parts = hmmss.split(' ').reverse();
                for (let j = 0; j < parts.length; j++) {
                    durationMs += parts[j] * Math.pow(60, j);
                }
                callLogs[i].duration = durationMs * 1000;
            }
        }
        return callLogs;
    }
    /**
     * @public
     * @method getMissedCallLogCounter
     * @instance
     * @description
     *    Get the number of call missed (state === "missed" && direction === "incoming")
     * @return {Number} The number of call missed
     */
    getMissedCallLogCounter() {
        let that = this;
        let num = 0;
        that.calllogs.callLogs.forEach(function (callLog) {
            if (!callLog.read && callLog.state === "missed" && callLog.direction === "incoming") {
                that.logger.log("info", LOG_ID + "(getMissedCallLogCounter) iter : ", num, ", callLog : ", callLog);
                num++;
            }
        });
        return num;
    }
    ;
    /**
     * @public
     * @method deleteOneCallLog
     * @instance
     * @description
     *    Delete a call log from it's id<br/>
     *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished
     * @param {String} id The call log id to remove
     * @return Nothing
     */
    deleteOneCallLog(id) {
        let that = this;
        that.logger.log("info", LOG_ID + "(deleteOneCallLog) id : ", id);
        return that._xmpp.deleteOneCallLog(id);
    }
    /**
     * @public
     * @method deleteCallLogsForContact
     * @instance
     * @description
     *    Delete all calls log items associated to a contact's given jid<br/>
     *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished
     * @param {String} jid The call log id to remove
     * @return Nothing
     */
    deleteCallLogsForContact(jid) {
        let that = this;
        that.logger.log("info", LOG_ID + "(deleteCallLogsForContact) jid : ", jid);
        return that._xmpp.deleteCallLogsForContact(jid);
    }
    /**
     * @public
     * @method deleteAllCallLogs
     * @instance
     * @description
     *    Delete all call logs history<br/>
     *    You have to listen to event `rainbow_oncalllogupdated` to know when the action is finished
     * @return Nothing
     */
    deleteAllCallLogs() {
        let that = this;
        that.logger.log("info", LOG_ID + "(deleteAllCallLogs)");
        return that._xmpp.deleteAllCallLogs();
    }
    /**
     * @public
     * @method markCallLogAsRead
     * @instance
     * @description
     *    Mark a call log item as read<br/>
     *    You have to listen to event `rainbow_oncalllogackupdated` to know when the action is finished
     * @param {String} id The call log id
     * @return Nothing
     */
    markCallLogAsRead(id) {
        let that = this;
        that.logger.log("info", LOG_ID + "(markCallLogAsRead) id : ", id);
        return that._xmpp.markCallLogAsRead(id);
    }
    /**
     * @public
     * @method markAllCallsLogsAsRead
     * @instance
     * @description
     *    Mark all call log items as read<br/>
     *    You have to listen to event `rainbow_oncalllogackupdated` to know when the action is finished
     * @return Nothing
     */
    markAllCallsLogsAsRead() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that.logger.log("info", LOG_ID + "(markAllCallsLogsAsRead) ");
            that.logger.log("internal", LOG_ID + "(markAllCallsLogsAsRead) that.calllogs.callLogs : ", that.calllogs.callLogs);
            yield that._xmpp.markAllCallsLogsAsRead(that.calllogs.callLogs);
        });
    }
    /**
     * @public
     * @method isInitialized
     * @instance
     * @description
     *    Check if the call log history has been received from Rainbow
     *    A false answer means that the call logs have not yet been retrieved from the server.
     * @return {Boolean} True if the call logs have been retrieved. False elsewhere.
     */
    isInitialized() {
        return this._initialized;
    }
    /*********************************************************/
    /**                  EVENT HANDLERS                     **/
    /*********************************************************/
    onCallLogUpdated(calllogs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.calllogs = calllogs;
            this._initialized = true;
        });
    }
    onCallLogAckReceived(calllogs) {
        return __awaiter(this, void 0, void 0, function* () {
            this.calllogs = calllogs;
            this._initialized = true;
        });
    }
    /*async onIqCallLogNotificationReceived(calllogs) {
        this.calllogs = calllogs ;
    } // */
    /*********************************************************/
    /**                  HELPER FUNCTIONS                   **/
    /*********************************************************/
    getOrderByNameCallLogs() {
        let that = this;
        return that.calllogs.orderByNameCallLogs;
    }
    getOrderByDateCallLogs() {
        let that = this;
        if (that.calllogs.orderByDateCallLogs.length !== 0) {
            that.calllogs.orderByDateCallLogs[0].isLatestCall = true; //update the latest callLog to show its subject next to the contact name.
            if (that.calllogs.orderByDateCallLogs[1]) {
                that.calllogs.orderByDateCallLogs[1].isLatestCall = false;
            }
        }
        return that.calllogs.orderByDateCallLogs;
    }
    getOrderByNameCallLogsBruts() {
        let that = this;
        return that.calllogs.orderByNameCallLogsBruts;
    }
    getOrderByDateCallLogsBruts() {
        let that = this;
        return that.calllogs.orderByDateCallLogsBruts;
    }
    //call logs where the contact is replaced by his JID or telephone number
    getSimplifiedCallLogs() {
        let that = this;
        return that.calllogs.simplifiedCallLogs;
    }
    getNumberMissedCalls() {
        let that = this;
        return that.calllogs.numberMissedCalls;
    }
    resetCallLogs() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that.logger.log("info", LOG_ID + "[resetCallLogs] resetCallLogs");
            that.calllogs = CallLogsBean();
            yield this._calllogEventHandler.resetCallLogs();
            yield that.getCallLogHistoryPage();
        });
    }
};
CallLogService = __decorate([
    Utils_1.logEntryExit(LOG_ID),
    Utils_2.isStarted([])
    /**
    * @module
    * @name CallsLog
     * @version 1.69.0-debug-24th-03-2020--03-54-58.0 
    * @public
    * @description
    *      This service allow to get the call log and manage it. <br><br>
    *      The main methods and events proposed in that service allow to: <br>
    *      - Get all calls log <br/>
    *      - Delete one or all calls log <br/>
    *      - Mark calls as read / unread <br/>
    */
], CallLogService);
exports.CallLogService = CallLogService;
module.exports.CallLogService = CallLogService;
//# sourceMappingURL=CallLogService.js.map
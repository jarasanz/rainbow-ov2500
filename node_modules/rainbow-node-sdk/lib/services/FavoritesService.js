"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("../common/Utils");
const PubSub = require("pubsub-js");
const favoriteEventHandler_1 = require("../connection/XMPPServiceHandler/favoriteEventHandler");
const Favorite_1 = require("../common/models/Favorite");
const ErrorManager_1 = require("../common/ErrorManager");
const Utils_2 = require("../common/Utils");
const LOG_ID = "FAVTE/SVCE - ";
let FavoritesService = 
/**
* @module
* @name FavoritesService
 * @version 1.69.0-debug-24th-03-2020--03-54-58.0 
 * @public
* @description
*      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.
*      The main methods and events proposed in that service allow to: <br>
*      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>
*      - Retrieve all information linked to that Favorite, <br>
*/
class FavoritesService {
    constructor(_eventEmitter, logger, _startConfig) {
        //public static $inject: string[] = ['$http', '$log', 'contactService', 'authService', 'roomService', 'conversationService', 'xmppService'];
        this.favorites = [];
        this.ready = false;
        /*********************************************************/
        /**                 LIFECYCLE STUFF                     **/
        /*********************************************************/
        this._startConfig = _startConfig;
        //let that = this;
        this._eventEmitter = _eventEmitter;
        this._xmpp = null;
        this._rest = null;
        this._s2s = null;
        this._options = {};
        this._useXMPP = false;
        this._useS2S = false;
        this._logger = logger;
        this.started = false;
        this._initialized = false;
        this._eventEmitter.on("evt_internal_favoritecreated_handle", this.onFavoriteCreated.bind(this));
        this._eventEmitter.on("evt_internal_favoritedeleted_handle", this.onFavoriteDeleted.bind(this));
        this.ready = false;
    }
    get startConfig() {
        return this._startConfig;
    }
    start(_options, _core) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that._xmpp = _core._xmpp;
            that._rest = _core._rest;
            that._options = _options;
            that._s2s = _core._s2s;
            that._useXMPP = that._options.useXMPP;
            that._useS2S = that._options.useS2S;
            this._favoriteHandlerToken = [];
            that._logger.log("info", LOG_ID + " ");
            that._logger.log("info", LOG_ID + "[start] === STARTING ===");
            let startDate = new Date().getTime();
            this.attachHandlers();
            //this.conversationService.favoriteService = this;
            //this.attachHandlers();
            let startDuration = Math.round(new Date().getTime() - startDate);
            //stats.push({ service: 'favoriteService', startDuration: startDuration });
            that._logger.log("info", LOG_ID + `=== STARTED (${startDuration} ms) ===`);
            this.ready = true;
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            that._logger.log("info", LOG_ID + "[stop] Stopping");
            //remove all saved call logs
            this.started = false;
            this._initialized = false;
            that._xmpp = null;
            that._rest = null;
            delete that._favoriteEventHandler;
            that._favoriteEventHandler = null;
            if (that._favoriteHandlerToken) {
                that._favoriteHandlerToken.forEach((token) => PubSub.unsubscribe(token));
            }
            that._favoriteHandlerToken = [];
            /*this.$log.info('Stopping');
            if (this._xmppManagementHandler) {
                this.xmppService.deleteHandler(this._xmppManagementHandler);
                this._xmppManagementHandler = null;
            }
            this.$log.info('Stopped');
    
             */
            this.ready = false;
            that._logger.log("info", LOG_ID + "[stop] Stopped");
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            yield this.getServerFavorites();
            /*await setTimeoutPromised(3000).then(() => {
                let startDate = new Date();
                that.getCallLogHistoryPage()
                    .then(() => {
                        // @ts-ignore
                        let duration = new Date() - startDate;
                        let startDuration = Math.round(duration);
                        that._logger.log("info", LOG_ID + " callLogService start duration : ",  startDuration);
                        that._logger.log("info", LOG_ID + "[start] === STARTED (" + startDuration + " ms) ===");
                        that.started = true;
                    })
                    .catch(() => {
                        that._logger.log("error", LOG_ID + "[start] === STARTING FAILURE ===");
                    });
            });
    
             */
        });
    }
    attachHandlers() {
        let that = this;
        that._logger.log("info", LOG_ID + "[attachHandlers] attachHandlers");
        that._favoriteEventHandler = new favoriteEventHandler_1.FavoriteEventHandler(that._xmpp, that);
        that._favoriteHandlerToken = [
            PubSub.subscribe(that._xmpp.hash + "." + that._favoriteEventHandler.MESSAGE_MANAGEMENT, that._favoriteEventHandler.onManagementMessageReceived),
            PubSub.subscribe(that._xmpp.hash + "." + that._favoriteEventHandler.MESSAGE_ERROR, that._favoriteEventHandler.onErrorMessageReceived)
        ];
        /*
        if (this._xmppManagementHandler) { this.xmppService.deleteHandler(this._xmppManagementHandler); }
        this._xmppManagementHandler = this.xmppService.addHandler((stanza) => { this.onXmppEvent(stanza); return true; }, null, "message", "management");

         */
        /*
        //if reconnection, update the call-logs
        if (that.started && that.lastTimestamp) {
            $interval(function () {
                that.getCallLogHistoryPage(that.lastTimestamp);
            }, 1000, 1, true);
        }
        // */
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getServerFavorites();
            //this.conversationService.favoriteService = this;
            this.attachHandlers();
        });
    }
    getServerFavorites() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let that = this;
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    this._rest.getServerFavorites().then((favorite) => __awaiter(this, void 0, void 0, function* () {
                        that._logger.log("info", LOG_ID + "(getServerFavorites) favorite tab length : ", favorite.length);
                        if (favorite) {
                            let promises = favorite.map((data) => __awaiter(this, void 0, void 0, function* () {
                                return this.createFavoriteObj(data.id, data.peerId, data.type);
                            }));
                            let favorites = yield Promise.all(promises);
                            this.favorites = favorites.filter((favorite) => {
                                return favorite !== null;
                            });
                            that._logger.log("info", LOG_ID + `getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);
                        }
                        resolve(this.favorites);
                    })).catch((err) => {
                        that._logger.log("error", LOG_ID + "(getServerFavorites) error.");
                        that._logger.log("internalerror", LOG_ID + "(getServerFavorites) error : ", err);
                        return reject(err);
                    });
                    /*
    //            let url = `${config.restServerUrl}/api/rainbow/enduser/v1.0/users/${this.contactService.userContact.dbId}/favorites`;
      //          let response = await this.$http({ method: "GET", url: url, headers: this.authService.getRequestHeader() });
                let promises = response.data.data.map(async (data: any) => { return this.createFavorite(data.id, data.peerId, data.type); });
                let favorites = await Promise.all(promises);
                this.favorites = favorites.filter((favorite) => { return favorite !== null; });
                this.$log.info(`getServerFavorites -- SUCCESS -- found ${this.favorites.length} favorites`);
                return this.favorites;
                */
                }));
            }
            catch (error) {
                let errorMessage = `getServerFavorites -- FAILURE -- ${error.message}`;
                this._logger.log("error", LOG_ID + `[getServerFavorites] CATCH Error !!! `);
                this._logger.log("internalerror", LOG_ID + `CATCH Error !!! : ${errorMessage}`);
                throw new Error(errorMessage);
            }
        });
    }
    addServerFavorite(peerId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            try {
                let favorite = yield that._rest.addServerFavorite(peerId, type);
                that._logger.log("internal", LOG_ID + `addServerFavorite(${peerId}, ${type}) -- SUCCESS`, favorite);
                return favorite;
            }
            catch (error) {
                let errorMessage = `addServerFavorite(${peerId}, ${type}) -- FAILURE -- ${error.message}`;
                that._logger.log("error", LOG_ID + `[addServerFavorite] Error.`);
                that._logger.log("internalerror", LOG_ID + `${errorMessage}`);
                throw new Error(errorMessage);
            }
        });
    }
    removeServerFavorite(favoriteId) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            try {
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    that._rest.removeServerFavorite(favoriteId).then((favoriteDeleted) => __awaiter(this, void 0, void 0, function* () {
                        that._logger.log("info", LOG_ID + "(removeServerFavorite) -- SUCCESS.");
                        that._logger.log("internal", LOG_ID + "(removeServerFavorite) -- SUCCESS : ", favoriteDeleted);
                        resolve(favoriteDeleted);
                    })).catch((err) => {
                        that._logger.log("error", LOG_ID + "(removeServerFavorite) error.");
                        that._logger.log("internalerror", LOG_ID + "(removeServerFavorite) error : ", err);
                        return reject(err);
                    });
                }));
            }
            catch (error) {
                let errorMessage = `removeServerFavorite(${favoriteId}) -- FAILURE -- ${error.statusText}`;
                that._logger.log("error", LOG_ID + `[removeServerFavorite] Error.`);
                that._logger.log("internalerror", LOG_ID + `${errorMessage}`);
                throw new Error(errorMessage);
            }
        });
    }
    toggleFavorite(conversation) {
        return __awaiter(this, void 0, void 0, function* () {
            let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;
            let type = conversation.contact ? (conversation.contact.isBot ? 'bot' : 'user') : 'room';
            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });
            if (!favorite) {
                return this.addServerFavorite(peerId, type);
            }
            else {
                return this.removeServerFavorite(favorite.id);
            }
        });
    }
    updateFavorites(conversation) {
        let peerId = conversation.contact ? conversation.contact.dbId : conversation.room.dbId;
        let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });
        if (favorite) {
            conversation.isFavorite = true;
            favorite.conv = conversation;
        }
    }
    getFavorite(peerId) {
        return __awaiter(this, void 0, void 0, function* () {
            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === peerId; });
            //let convGetter = favorite.contact ? this.conversationService.getOrCreateOneToOneConversation(favorite.contact.jid) : this.conversationService.getRoomConversation(favorite.room.jid);
            //return await convGetter;
        });
    }
    createFavoriteObj(id, peerId, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            try {
                let favorite = new Favorite_1.Favorite(id, peerId, type);
                /*
                // Get peer object
                if (type === 'room') { favorite.room = this.roomService.getRoomById(peerId); }
                else { favorite.contact = await this.contactService.getContactByDBId(peerId); }
    
                // Fetch eventual conversation
                let convId: string = favorite.room ? favorite.room.jid : favorite.contact.jid;
                let conv: any = this.conversationService.getConversationById(convId);
                if (conv) { conv.isFavorite = true; favorite.conv = conv; }
    
                 */
                return favorite;
            }
            catch (error) {
                that._logger.log("error", LOG_ID + `[createFavorite] Error.`);
                that._logger.log("internalerror", LOG_ID + `createFavorite(${id}, ${peerId}, ${type}) -- FAILURE -- ${error.message}`);
                return null;
            }
        });
    }
    onXmppEvent(stanza) {
        return __awaiter(this, void 0, void 0, function* () {
            try { /*
                let stanzaElem = $(stanza);
                let favoriteElem = stanzaElem.find("favorite");
                if (favoriteElem) {
                    let id = favoriteElem.attr("id");
                    let type = favoriteElem.attr("type");
                    let peerId = favoriteElem.attr("peer_id");
                    let action = favoriteElem.attr("action");
    
                    if (action === 'create') {
                        let favorite: Favorite = this.favorites.find((favoriteConv: any) => { return favoriteConv.peerId === peerId; });
                        if (!favorite) {
                            favorite = await this.createFavorite(id, peerId, type);
                            this.favorites.push(favorite);
                            this.sendEvent('ON_FAVORITE_CREATED', { favorite });
                        }
                    }
    
                    if (action === 'delete') {
                        let index = this.favorites.findIndex((fav) => { return fav.id === id; });
                        if (index !== -1) {
                            let favorite = this.favorites[index];
                            if (favorite.conv) { favorite.conv.isFavorite = false; }
                            this.favorites.splice(index, 1);
                            this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });
                        }
                    }
                }
                return true;
                */
            }
            catch (error) {
                return true;
            }
        });
    }
    /*private sendEvent(eventName: string, detail: any): void {
        let event = new CustomEvent(eventName, { detail });
        window.dispatchEvent(event);
    }

     */
    /**
     * @public
     * @since 1.56
     * @method fetchAllFavorites()
     * @instance
     * @description
     *   Fetch all the Favorites from the server in a form of an Array
     * @return {Conversation[]} An array of Favorite objects
     */
    fetchAllFavorites() {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            return new Promise((resolve, reject) => {
                that.getServerFavorites()
                    .then(function (favorites) {
                    that._logger.log("debug", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites`);
                    that._logger.log("internal", LOG_ID + `[fetchAllFavorites] :: Successfully fetched the Favorites : `, favorites);
                    resolve(favorites);
                })
                    .catch(function (err) {
                    that._logger.log("error", LOG_ID + `[fetchAllFavorites] :: Error.`);
                    that._logger.log("internalerror", LOG_ID + `[fetchAllFavorites] :: ERROR : `, err);
                    return reject(err);
                });
            });
        });
    }
    ;
    /**
     * @public
     * @since 1.56
     * @method createFavorite()
     * @instance
     * @description
     *   Add conversation/bubble/bot to Favorites Array
     * @param {String} id of the conversation/bubble
     * @param {String} type of Favorite (can be 'user' or 'bubble')
     * @return {Promise<Favorite>} A Favorite object
     */
    createFavorite(id, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            return new Promise((resolve, reject) => {
                if (!id) {
                    that._logger.log("debug", LOG_ID + "[createFavorite] :: Error: parameter 'id' is missing or null");
                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);
                }
                if (!type) {
                    that._logger.log("debug", LOG_ID + "[createFavorite] :: Error: parameter 'type' is missing or null");
                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);
                }
                if (type !== "bubble" && type !== "user") {
                    that._logger.log("debug", LOG_ID + "[createFavorite] :: Error: type should be set to \"user\" or \"bubble\"");
                    return reject(ErrorManager_1.ErrorManager.getErrorManager().BAD_REQUEST);
                }
                if (type === "bubble") {
                    type = "room";
                }
                that.addServerFavorite(id, type).then((favorite) => {
                    that._logger.log("debug", LOG_ID + `[createFavorite] :: Successfully added ${type} to favorites`);
                    return resolve(favorite);
                }).catch(err => {
                    that._logger.log("error", LOG_ID + "[createFavorite] :: Error.");
                    that._logger.log("internalerror", LOG_ID + "[createFavorite] :: Error : ", err);
                    return reject(err);
                });
            });
        });
    }
    ;
    /**
     * @public
     * @since 1.56
     * @method deleteFavorite()
     * @instance
     * @description
     *   Delete conversation/bubble/bot from Favorites Array
     * @param {String} id of the Favorite item
     * @return {Favorite[]} A Favorite object
     */
    deleteFavorite(id) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            return new Promise((resolve, reject) => {
                if (!id) {
                    that._logger.log("debug", LOG_ID + "[deleteFavorite] :: Error: parameter 'id' is missing or null");
                    return reject("[deleteFavorite] :: Error: parameter 'id' is missing or null");
                }
                that.removeServerFavorite(id)
                    .then((favDeleted) => {
                    return resolve(favDeleted);
                })
                    .catch(err => {
                    that._logger.log("error", LOG_ID + "[deleteFavorite] :: Error.");
                    that._logger.log("internalerror", LOG_ID + "[deleteFavorite] :: Error : ", err);
                    return reject(err);
                });
            });
        });
    }
    // ******************* Event XMPP parsed in favoriteEventHandler ***************
    onFavoriteCreated(fav) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            let favorite = this.favorites.find((favoriteConv) => { return favoriteConv.peerId === fav.peerId; });
            if (!favorite) {
                favorite = yield this.createFavoriteObj(fav.id, fav.peerId, fav.type);
                this.favorites.push(favorite);
                //that._logger.log("internal", LOG_ID + "[onFavoriteCreated] send event : ", favorite);
                //this.sendEvent('ON_FAVORITE_CREATED', { favorite });
                that._eventEmitter.emit("evt_internal_favoritecreated", favorite);
            }
        });
    }
    onFavoriteDeleted(fav) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            let index = this.favorites.findIndex((fav) => { return fav.id === fav.id; });
            if (index !== -1) {
                let favorite = this.favorites[index];
                if (favorite.conv) {
                    favorite.conv.isFavorite = false;
                }
                this.favorites.splice(index, 1);
                //that._logger.log("debug", LOG_ID + "[onFavoriteDeleted] send event : ", { favoriteId: favorite.id });
                //this.sendEvent('ON_FAVORITE_DELETED', { favoriteId: favorite.id });
                that._eventEmitter.emit("evt_internal_favoritedeleted", fav);
            }
        });
    }
};
FavoritesService = __decorate([
    Utils_1.logEntryExit(LOG_ID),
    Utils_2.isStarted([])
    /**
    * @module
    * @name FavoritesService
     * @version 1.69.0-debug-24th-03-2020--03-54-58.0 
     * @public
    * @description
    *      This module is the basic module for handling Favorites in Rainbow. In Rainbow, Favorites are the way to list a most frequent, most used or the most important conversations, bubbles and bots.
    *      The main methods and events proposed in that service allow to: <br>
    *      - Create or delete a Rainbow Favorite (one-to-one, bubble or bot), <br/>
    *      - Retrieve all information linked to that Favorite, <br>
    */
], FavoritesService);
exports.FavoritesService = FavoritesService;
module.exports.FavoritesService = FavoritesService;
//# sourceMappingURL=FavoritesService.js.map
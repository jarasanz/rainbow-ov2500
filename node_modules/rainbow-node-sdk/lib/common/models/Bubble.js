"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = require("../Utils");
function randomString(length = 10) {
    let string = "";
    let rnd;
    const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    while (length > 0) {
        rnd = Math.floor(Math.random() * chars.length);
        string += chars.charAt(rnd);
        length--;
    }
    return string;
}
function getUserAdditionDate(user) {
    if (user && user.additionDate) {
        try {
            return new Date(user.additionDate).getTime();
        }
        catch (err) {
            console.error("Error while getUserAdditionDate!!!");
        }
    }
    return 0;
}
function sortUsersByDate(userADate, userBDate) {
    let res = 0;
    if (userADate && userBDate) {
        if (userADate < userBDate) {
            res = -1;
        }
        if (userADate > userBDate) {
            res = 1;
        }
    }
    /*
    //res = 1;
    // */
    return res;
}
/**
 * @class
 * @name Bubble
 * @description
 *      This class represents a Bubble. <br>
 *		A bubble is an interaction between several participants based on IM media. A bubble is described by a name and a description.<br>
 *		Like for one-to-one conversation, A conversation within a bubble never ends and all interactions done can be retrieved. <br>
 */
class Bubble {
    constructor(_id = "", _name = "", _topic = "", _jid = "", _creator = "", _history = "none", _users = [], _creationDate = "", _visibility = "private", _customData = {}, _isActive = false, _conference, _disableNotifications = false, _lastAvatarUpdateDate = null, _guestEmails = [], _confEndpoints = [], _activeUsersCounter = 0, _autoRegister = false, _lastActivityDate, _avatarDomain = "", autoAcceptInvitation = false) {
        /**
         * @public
         * @readonly
         * @property {string} id The ID of the Bubble
         * @instance
         */
        this.id = _id;
        /**
         * @public
         * @readonly
         * @property {string} name The name of the Bubble
         * @instance
         */
        this.name = _name;
        /**
         * @public
         * @readonly
         * @property {string} topic The topic of the Bubble
         * @instance
         */
        this.topic = _topic;
        /**
         * @public
         * @readonly
         * @property {string} jid The JID of the Bubble
         * @instance
         */
        this.jid = _jid;
        /**
         * @public
         * @readonly
         * @property {string} creator The ID of the creator of the Bubble
         * @instance
         */
        this.creator = _creator;
        /**
         * @public
         * @readonly
         * @property {string} history The type of history the bubble supports. Can be 'none' (no history) or 'full' (Full bubble history is accessible for newcomers)
         * @instance
         */
        this.history = _history;
        /**
         * @public
         * @readonly
         * @property {Object[]} users The list of users of that Bubble with their status and privilege. Note : Only 100 users are return by the server. So if there are more than this limit, you have to retrieve them with the method BubblesService::getUsersFromBubble
         * @instance
         */
        if (_users) {
            // need to order the users by date
            this.users = Utils_1.orderByFilter(_users, getUserAdditionDate, false, sortUsersByDate);
            /*
            console.log("users ordered in bubble (" + this.id + ") : ", this.users);
            // */
        }
        else {
            this.users = _users;
        }
        /**
         * @public
         * @readonly
         * @property {string} organizers of the bubble, built from users property. It is affected by the limit of 100 (splitted between organizers and members).
         * @instance
         */
        this.organizers = [];
        /**
         * @public
         * @readonly
         * @property {string} members of the bubble, built from users property. It is affected by the limit of 100 (splitted between organizers and members).
         * @instance
         */
        this.members = [];
        /**
         * @public
         * @readonly
         * @property {string} creationDate The creation date of the Bubble
         * @instance
         */
        this.creationDate = _creationDate;
        /**
         * @public
         * @readonly
         * @property {string} visibility The visibility of the Bubble. Can be private (only visible for members) or public
         * @instance
         */
        this.visibility = _visibility;
        /**
         * @public
         * @readonly
         * @property {Object} customData The custom data attached to that Bubble. List of pairs (key/value).
         * @instance
         */
        this.customData = _customData;
        /**
         *
         * @type {boolean}
         */
        this.isActive = _isActive;
        /**
         * @private
         * @property {string} lastActivityDate The date of the last activity in this bubble
         * @readonly
         */
        this.lastActivityDate = _lastActivityDate;
        this.conference = _conference;
        this.disableNotifications = _disableNotifications;
        this.lastAvatarUpdateDate = _lastAvatarUpdateDate;
        this.guestEmails = _guestEmails;
        this.confEndpoints = _confEndpoints;
        this.activeUsersCounter = _activeUsersCounter;
        /**
         * @property {string} avatar This is the URL to download the avatar of the bubble. Note that it is an unavailable url if no avatar has been setted.
         */
        this.avatar = _avatarDomain + "/api/room-avatar/" + _id + "?size=512&rand=" + randomString();
        /**
         * @public
         * @readonly
         * @property  {String} autoRegister    A user can create a room and not have to register users. He can share instead a public link also called 'public URL'(<a href="#api-users_rooms_public_link">users public link</a>).
         * </br>According with autoRegister value, if another person uses the link to join the room:
         * <ul>
         * <li>autoRegister = 'unlock':</br>
         *    If this user is not yet registered inside this room, he is automatically included with the status 'accepted' and join the room.</li>
         * <li>autoRegister = 'lock':</br>
         *    If this user is not yet registered inside this room, he can't access to the room. So that he can't join the room.</li>
         * <li>autoRegister = 'unlock_ack':</br>
         *    If this user is not yet registered inside this room, he can't access to the room waiting for the room's owner acknowledgment.</li>
         * </ul>
         * @instance
         */
        this.autoRegister = _autoRegister;
        this.owner = false;
        /**
         * @description auto acceptation of the bubble.
         */
        this.autoAcceptInvitation = autoAcceptInvitation;
    }
    /**
     * Method helper to know if room is a meeting
     * @private
     */
    isMeetingBubble() {
        if (this.conference && this.conference.mediaType === "pstnAudio") {
            return true;
        }
        return false;
    }
    getStatusForUser(userId) {
        let that = this;
        let user = that.users.find((user) => {
            return user.userId === userId;
        });
        return user ? user.status : "none";
    }
    setUsers(_users) {
        if (_users) {
            // need to order the users by date
            this.users = Utils_1.orderByFilter(_users, getUserAdditionDate, false, sortUsersByDate);
            /*
            // console.log("users ordered in bubble (" + this.id + ") : ", this.users);
            // */
        }
        else {
            this.users = _users;
        }
    }
    updateBubble(data, contactsService) {
        return __awaiter(this, void 0, void 0, function* () {
            let that = this;
            if (data) {
                let bubbleproperties = Object.getOwnPropertyNames(that);
                //console.log("updateBubble update Bubble with : ", data["id"]);
                Object.getOwnPropertyNames(data).forEach((val, idx, array) => {
                    //console.log(val + " -> " + data[val]);
                    if (bubbleproperties.find((el) => {
                        return val == el;
                    })) {
                        /*
                        // console.log("WARNING : One property of the parameter of BubbleFactory method is not present in the Bubble class : ", val, " -> ", data[val]);
                        // */
                        if (val === "users") {
                            /*
                            // console.log("update users in bubble : ", data[val]);
                            // */
                            that.setUsers(data[val]);
                        }
                        else {
                            that[val] = data[val];
                        }
                    }
                    else {
                        //console.log("WARNING : One property of the parameter of BubbleFactory method is not present in the Bubble class can not update Bubble with : ", val, " -> ", data[val]);
                        console.log("WARNING : One property of the parameter of BubbleFactory method is not present in the Bubble class can not update Bubble property : ", val);
                    }
                });
                if (data.creator) {
                    that.ownerContact = yield contactsService.getContactById(data.creator, false);
                    that.owner = (that.ownerContact.jid === contactsService.userContact.jid);
                }
            }
            return this;
        });
    }
    /**
     * @function
     * @public
     * @name BubbleFactory
     * @description
     * This class is used to create a bubble from data object
     */
    static BubbleFactory(avatarDomain, contactsService) {
        //     constructor(_id : any = "", _name: any = "", _topic: any = "", _jid: any = "", _creator: any = "", _history: any = "none", _users: any = [],
        //     _creationDate: any = "", _visibility: any = "private", _customData: any = {}, _isActive: any = false, _conference: any) {
        return (data) => __awaiter(this, void 0, void 0, function* () {
            let bubble = new Bubble(data.id, data.name, data.topic, data.jid, data.creator, data.history, data.users, data.creationDate, data.visibility, data.customData, data.isActive, data.conference, data.disableNotifications, data.lastAvatarUpdateDate, data.guestEmails, data.confEndpoints, data.activeUsersCounter, data.autoRegister, data.lastActivityDate, data.autoAcceptInvitation, avatarDomain);
            if (data) {
                let bubbleproperties = Object.getOwnPropertyNames(bubble);
                Object.getOwnPropertyNames(data).forEach((val, idx, array) => {
                    //console.log(val + " -> " + data[val]);
                    if (!bubbleproperties.find((el) => {
                        return val == el;
                    })) {
                        //console.log("WARNING : One property of the parameter of BubbleFactory method is not present in the Bubble class : ", val, " -> ", data[val]);
                        console.log("WARNING : One property of the parameter of BubbleFactory method is not present in the Bubble class : ", val);
                    }
                });
                if (data.creator) {
                    yield contactsService.getContactById(data.creator, false).then((result) => {
                        //console.log("(BubbleFactory) getContactById : ", result);
                        bubble.ownerContact = result;
                        if (bubble.ownerContact) {
                            if (bubble.ownerContact.jid === contactsService.userContact.jid) {
                                bubble.owner = true;
                            }
                            else {
                                // console.log("(BubbleFactory) OWNER false : " + bubble.ownerContact.jid + " : " + contactsService.userContact.jid);
                                bubble.owner = false;
                            }
                        }
                        else {
                            console.log("(BubbleFactory) ownerContact empty.");
                        }
                    });
                }
            }
            return bubble;
        });
    }
}
exports.Bubble = Bubble;
Bubble.RoomUserStatus = {
    "INVITED": "invited",
    "ACCEPTED": "accepted",
    "UNSUBSCRIBED": "unsubscribed",
    "REJECTED": "rejected",
    "DELETED": "deleted"
};
/**
 * @private
 * @readonly
 * @enum {number}
 */
Bubble.Type = {
    "PRIVATE": 0,
    "PUBLIC": 1
};
/**
 * @public
 * @readonly
 * @enum {String}
 */
Bubble.Privilege = {
    /** User level */
    "USER": "user",
    /** Moderator level */
    "MODERATOR": "moderator",
    /** Guest level */
    "GUEST": "guest"
};
/**
 * @public
 * @readonly
 * @enum {String}
 */
Bubble.History = {
    /** Full bubble history is accessible for newcomers */
    "ALL": "all",
    /** No history is accessible for newcomers, only new messages posted */
    "NONE": "none"
};
module.exports = { Bubble };
//# sourceMappingURL=Bubble.js.map